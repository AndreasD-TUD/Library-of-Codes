---
title: "Deskriptive Statistiken"
author: "Andreas Deim"
date: "2024-12-01"
output:
  github_document:
    toc: true
    toc_depth: 2
---

## Pakete Laden

```{r, eval=FALSE}
#Falls nicht Installiert, dann mit install.pakages("...") installieren
install.packages("sjmisc")
install.packages ("sjPlot")

```

```{r, message=FALSE, warning=FALSE}
library(haven)
library(dplyr)
library(tidyr)
library(psych)
library(sjmisc)
library(sjPlot)
```

## Datensatz laden

Unseren Datensatz nennen wir der einfachheitshalber `data`.

```{r}
data<-read_spss(file = "ESS10.sav")
```

## Deskriptive Analyse

### Exkurs: Human Values nach Schwartz

Eine Besonderheit bei den Human Values ist, dass diese je nach Anwendung noch auf den individuellen Mittelwert zentriert werden müssen. Stellen wir uns vor, zwei Personen besitzen bei Universalismus den selben Wert von 3, allerdings gibt Person A bei allen anderen Human Values niedrigere Werte und Person B höhere Werte an.Somit steht Universalismus bei beiden Personen in einem anderen Kontext, auch wenn es den selben Wert besitzt. Mit der Zentrierung wollen wir die individuelle Priorsierung der Befragten berücksichtigen.

Referenz: Schwartz, S. (2007). Value orientations: measurement, antecedents and consequences across nations. In *Measuring Attitudes Cross-Nationally* (pp. 169-203). SAGE Publications, Ltd, <https://doi.org/10.4135/9781849209458>

Zuerst müssen wir alle 10 Werteausprägungen erster Ordnung errechnen und dann den Mittelwert aller Items von den Werteausprägungen abziehen. Anschließen fügen wir die Werte dem Datensatz hinzu.

**Achtung:** Die folgenden Berechnungen können viel Zeit in Anspruch nehmen. Alternativ kann von Opal der bereits abgeänderte Datensatz "ESS10_HV.sav" eingeladen werden

```{r, eval=FALSE}
# Erste Schritt Berechnung des gesamten Mittelwerts den wir dann abziehen wollen

data <- data %>%
  rowwise() %>%
  mutate(hv_mean = mean(c(ipcrtiv, imprich, ipeqopt, ipshabt, impsafe, impdiff, ipfrule, ipudrst, ipmodst, ipgdtim, impfree, iphlppl, ipsuces, ipstrgv, ipadvnt, ipbhprp, iprspot, iplylfr, impenv, imptrad, impfun), na.rm = T))

#Zweiter Schritt Entwicklung der Wertauspärgung 1. Ordnung

#1. Self-Direction
data <- data %>%
  rowwise() %>%
  mutate(hv_selfd = mean(c(ipcrtiv, impfree), na.rm = T) - hv_mean)

#2. Power
data <- data %>%
  rowwise() %>%
  mutate(hv_power = mean(c(imprich, iprspot), na.rm = T) - hv_mean)

#3. Universalism
data <- data %>%
  rowwise() %>%
  mutate(hv_univ = mean(c(ipeqopt, ipudrst, impenv), na.rm = T) - hv_mean)

#4. Achievement
data <- data %>%
  rowwise() %>%
  mutate(hv_achiev = mean(c(ipshabt, ipsuces), na.rm = T) - hv_mean)

#5. Security
data <- data %>%
  rowwise() %>%
  mutate(hv_secur = mean(c(impsafe, ipstrgv), na.rm = T) - hv_mean)

#6. Stimulation
data <- data %>%
  rowwise() %>%
  mutate(hv_stim = mean(c(impdiff, ipadvnt), na.rm = T) - hv_mean)

#7. Conformity
data <- data %>%
  rowwise() %>%
  mutate(hv_conf = mean(c(ipfrule, ipbhprp), na.rm = T) - hv_mean)

#8. Tradition
data <- data %>%
  rowwise() %>%
  mutate(hv_trad = mean(c(ipmodst, imptrad), na.rm = T) - hv_mean)

#9. Hedonism
data <- data %>%
  rowwise() %>%
  mutate(hv_hedon = mean(c(ipgdtim, impfun), na.rm = T) - hv_mean)

#10. Benevolence
data <- data %>%
  rowwise() %>%
  mutate(hv_benev = mean(c(iphlppl, iplylfr), na.rm = T) - hv_mean)

```

Damit können nun die Werteausprägungen für die weitere Berechnung verwendet werden.

### Häufigkeiten

Einen ersten schönen Überblick erhalten wir mit dem *sjmisc*-Paket. Der Befehl `frq()` gibt uns zuerst die Häufigkeiten aus der einzelnen Wertausprägungen aus.

Mit der Option `frq(..., out = "viewer")` geben wir an, dass wir die Ergebnisse in einer Tabelle im Fenster viewer (unten rechts) ausgegeben haben wollen.

```{r}

frq(data$wrclmch, out = "viewer")

```

In der Tabelle werden Spaltenweise von links nach rechts der numerische Wert der Wertausprägung, die Bezeichnung der Wertausprägung, die absolute Häufigkeit (Anzahl der Häufigkeit), die relative Häufigkeit (NA berücksichtig), die relative Häufigkeit (NA vernachlässigt) und die kumulierte relative Häufigkeit (NA vernachlässigt) dargestellt.

Unterhalb der Tabelle werden zudem die gesamte Anzahl der befragten Personen (mit und ohne Berücksichtigung der NA), der Mittelwert und die Standardabweichung angezeigt.

Wenn wir nun die Werte nach bestimmten Gruppen oder Ländern ausgegeben benötigen, so können wir uns wieder dem `filter()` Befehl aus *dplyr* bemächtigen.

```{r}
data %>%
  filter(cntry == "GB") %>%
  frq(wrclmch, out = "viewer")

#oder

data %>%
  filter(gndr == 2) %>%
  frq(wrclmch, out = "viewer")
```

### Mittelwert, Standardabweichung und mehr

Nachdem wir uns die Häufigkeiten angeschaut haben, möchten wir uns nun die weiteren deskriptiven Statistiken anschauen. Dafür verwenden wir den Befehl `describe()` des *psych*-Paketes

```{r}

describe(data$wrclmch, na.rm = T)
```

Wir erhalten von links nach rechts:

vars = Itemnummer\
n = Anzahl gültiger Werte\
mean = Mittelwert\
sd = Standardabweichung\
median = Median\
trimmed = getrimmter Mittelwert (Grenze bei 0.1)\
mad = mittlere absolute Abweichung vom Median\
min = Minimum\
max = Maximum\
skew = Schiefe der Verteilung\
kurtosis = Kurtosis (Wölbung der Verteilung)\
se =Standardfehler der Verteilung

Wenn wir nach Gruppen eine Analyse haben möchten so können wir entweder mit `select()` oder mit `describeBy()` arbeiten.

```{r}
describeBy(data$wrclmch, data$cntry, mat = T, na.rm = T)
```

Mit dem Befehl `describe.by(data$wrclmch, data$cntry, mat = T, na.rm = T)` lassen wir uns alle deskriptiven Statistiken zu jedem Land separat ausgeben. Dabei geben wir zuerst die Variable an, die berechnet und dann die Variable, nach der gruppiert werden soll. Mit `mat = T` geben wir an, dass wir das Ergebnis in einer tabellarischen Form ausgegeben haben wollen.

```{r}
data %>%
  filter(cntry %in% c("GB", "BE", "IT")) %>%
  group_by(cntry) %>%
  summarise(describe(wrclmch, na.rm = T))
```

### Alternative Einzelberechnungen

Wollen wir die deskriptiven Statistiken einzeln Berechnen, so können wir folgende Befehle verwenden:

**Anzahl**

```{r}
data %>% ungroup() %>% summarize(length(wrclmch))

```

**Mittelwert**

```{r}
data %>% ungroup() %>% summarize(mean(wrclmch, na.rm = T))
```

**Standardabweichung**

```{r}
data %>% ungroup() %>% summarize(sd(wrclmch, na.rm = T))
```

**Varianz**

```{r}
data %>% ungroup() %>% summarize(var(wrclmch, na.rm = T))
```

**Median**

```{r}
data %>% ungroup() %>% summarize(median(wrclmch, na.rm = T))
```

**Häufigkeitstabelle**

```{r}
data %>% select(wrclmch) %>% table(., useNA = "ifany")
```

**Quantile und Percentile**

```{r}
data %>% ungroup() %>% summarize(quantile(wrclmch,probs = seq(0.25, 1, 0.25), na.rm = T)) #Beginn bei 25%

data %>% ungroup() %>% summarize(quantile(wrclmch,probs = seq(0.1, 1, 0.1), na.rm = T)) #Beginn bei 10%
```

Min, Max und Range

```{r}
data %>% ungroup() %>% summarize(min(wrclmch, na.rm = T))

data %>% ungroup() %>% summarize(max(wrclmch, na.rm = T))

data %>% ungroup() %>% summarize(range(wrclmch, na.rm = T))
```
